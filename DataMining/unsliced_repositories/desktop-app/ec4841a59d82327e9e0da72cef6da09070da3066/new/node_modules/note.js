var async = require('async');
var db = require('db');
var fs = require('fs');
var File = require('file');
var Evt = require('evt');
var User = require('user');
var Notebook = require('notebook');
// var Tag = require('tag');
// var Api = require('api');
var Server = require('server');
var Common = require('common');
var Web = require('web');
var Notes = db.notes;

var Api = null; // require('api')
var Tag = null;

function log(o) {
	console.log(o);
}

// 笔记服务
var Note = {
	/*
	type NoteOrContent struct {
		NotebookId string
		NoteId string
		UserId string
		Title string
		Desc string
		ImgSrc string
		Tags []string
		Content string
		Abstract string
		IsNew bool
		IsMarkdown bool
		FromUserId string // 为共享而新建
		IsBlog bool // 是否是blog, 更新note不需要修改, 添加note时才有可能用到, 此时需要判断notebook是否设为Blog
	}
	 */
	// 更新笔记
	updateNoteOrContent: function(noteOrContent, callback) {
		var userId = User.getCurActiveUserId();
		noteOrContent['UserId'] = userId;
		console.log('updateNoteOrContent: ' + noteOrContent.NoteId);
		var date = new Date();
		noteOrContent.UpdatedTime = date;

		noteOrContent['IsDirty'] = true; // 已修改
		noteOrContent['LocalIsDelete'] = false;

		// 新建笔记, IsNew还是保存着
		if(noteOrContent.IsNew) {
			noteOrContent.CreatedTime = date;
			noteOrContent['IsTrash'] = false;
			delete noteOrContent['IsNew'];
			noteOrContent['LocalIsNew'] = true;
			Notes.insert(noteOrContent, function (err, newDoc) {   // Callback is optional
				if(err) {
					console.log(err);
					callback && callback(false);
				} else {
					// 为什么又设置成true, 因为js的对象是共享的, callback用到了noteOrContent.IsNew来做判断
					noteOrContent['IsNew'] = true;
					callback && callback(newDoc);

					// 重新统计笔记本的笔记数量
					Notebook.reCountNotebookNumberNotes(noteOrContent.NotebookId);
					/*
					// 标签
					if(noteOrContent.Tags && noteOrContent.Tags.length > 0) {
						Tag.addTags(noteOrContent.Tags);
					}
					*/
				}
			});
		// 更新笔记
		} else {
			var updateFields = ['Desc', 'ImgSrc', 'Title', 'Tags', 'Content'];
			var updates = {};
			var needUpdate = false;
			for(var i in updateFields) {
				var field = updateFields[i];
				if(field in noteOrContent) {
					updates[field] = noteOrContent[field];
					needUpdate = true;
				}
			}
			if('Content' in updateFields) {
				// 内容更新了, 因为内容是以后才从远程获取的, 获取内容后改变ContentIsDirty=false
				noteOrContent['ContentIsDirty'] = true;
			}
			if(needUpdate) {
				updates['IsDirty'] = true;
				updates['LocalIsDelete'] = false;
				updates.UpdatedTime = date;
				// Set an existing field's value 
				Notes.update({NoteId: noteOrContent.NoteId}, { $set: updates }, {}, function (err, numReplaced) { 
					if(err) {
						callback && callback(false);
					} else {
						callback && callback(noteOrContent);
					}
				});
			}
		}
	},

	// 获取笔记列表
	getNotes: function(notebookId, callback) {
		var me = this;
		me._getNotes(notebookId, false, false, callback);
	},
	// 获取trash笔记
	getTrashNotes: function(callback) {
		var me = this;
		me._getNotes('', true, false, callback);
	},
	getStarNotes: function(callback) {
		var me = this;
		me._getNotes('', false, true, callback);
	},
	_getNotes: function(notebookId, isTrash, isStar, callback) {
		var userId = User.getCurActiveUserId();
		var query = {
			UserId: userId,
			IsTrash: false,
			LocalIsDelete: false, // 未删除的
		};
		if(isStar) {
			query['Star'] = true;
		}
		if(notebookId) {
			query['NotebookId'] = notebookId;
		}
		if(isTrash) {
			query['IsTrash'] = true;
		}
		Notes.find(query).sort({'UpdatedTime': -1}).exec(function(err, notes) {
			if(err) {
				log(err);
				return callback && callback(false);
			}
			return callback && callback(notes);
		});
	},

	searchNote: function(key, callback) {
		var reg = new RegExp(key);
		Notes.find({IsTrash: false, LocalIsDelete: false, $or: [{Title: reg}, {Content: reg}]}).sort({'UpdatedTime': -1}).exec(function(err, notes) {
			if(!err && notes) {
				console.log('search ' + key + ' result: ' + notes.length);
				callback(notes);
			} else {
				callback([]);
			}
		});
	},

	searchNoteByTag: function(tag, callback) {
		Notes.find({IsTrash: false, LocalIsDelete: false, Tags: {$in: [tag]}}).sort({'UpdatedTime': -1}).exec(function(err, notes) {
			if(!err && notes) {
				console.log('search by tag: ' + tag + ' result: ' + notes.length);
				callback(notes);
			} else {
				callback([]);
			}
		});
	},

	deleteNote: function(noteId, callback) {
		Notes.update({NoteId: noteId}, {$set: {IsTrash: true, IsDirty: true}}, function(err, n) {
			if(err || !n) {
				callback(false);
			} else {
				callback(true);
			}
		});
	},
	// 彻底删除笔记, 如果有tags, 则需要更新tags's count
	deleteTrash: function(noteId, callback) {
		var me = this;
		me.getNote(noteId, function(note) {
			if(note) {
				note.LocalIsDelete = true;
				note.IsDirty = true;

				// TODO 删除附件

				Notes.update({_id: note._id}, {$set: {IsDirty: true, LocalIsDelete: true}}, function(err, n) {
					if(n) {
						// 如果有tags, 则重新更新tags' count
						me.updateTagCount(note.Tags);
					}
				});
			} else {
				callback(false);
			}
		});

		Notes.update({NoteId: noteId}, {$set: {IsDirty: true, LocalIsDelete: true}}, function(err, n) {
			if(err || !n) {
				callback(false);
			} else {


				callback(true);
			}
		});
	},

	// 移动note
	// 重新统计另一个notebookId的笔记数
	moveNote: function(noteId, notebookId, callback) {
		var me = this;
		me.getNote(noteId, function(note) {
			if(note) {
				var to = !note.Star;
				var preNotebookId = note.NotebookId;
				note.NotebookId = notebookId;
				Notes.update({_id: note._id}, {$set: {NotebookId: notebookId, IsTrash: false, LocalIsDelete: false, UpdatedTime: new Date()}}, function(err, n) {
					// 重新统计
					Notebook.reCountNotebookNumberNotes(preNotebookId);
					Notebook.reCountNotebookNumberNotes(notebookId);
					callback(note);
				});
			} else {
				callback(false);
			}
		});
	},

	// 加星或取消
	star: function(noteId, callback) {
		var me = this;
		me.getNote(noteId, function(note) {
			if(note) {
				var to = !note.Star;
				Notes.update({_id: note._id}, {$set: {Star: to, UpdatedTime: new Date()}});
				callback(true, to);
			}
		});
	},

	conflictIsFixed: function(noteId) {
		var me = this;
		Notes.update({NoteId: noteId}, {$set: {ConflictNoteId: ""}});
	},

	// 笔记本下是否有笔记
	hasNotes: function(notebookId, callback) {
		Notes.count({NotebookId: notebookId, IsTrash: false, LocalIsDelete: false}, function(err, n) {
			console.log(n);
			if(err || n > 0) {
				return callback(true);
			}
			callback(false);
		});
	},

	// 得到笔记
	getNote: function(noteId, callback) {
		var me = this;
		Notes.findOne({NoteId: noteId}, function(err, doc) {
			if(err || !doc) {
				log('不存在');
				callback && callback(false);
			} else {
				callback && callback(doc);
			}
		});
	},

	// 服务器上的数据到本地
	fixNoteContent: function(content) {
		if(!content) {
			return content;
		}
		
		var reg = new RegExp(Evt.leanoteUrl + '/api/file/getImage', 'g');
		content = content.replace(reg, Server.localUrl + '/api/file/getImage');

		var reg2 = new RegExp(Evt.leanoteUrl + '/api/file/getAttach', 'g');
		content = content.replace(reg, Evt.localUrl + '/api/file/getAttach');

		var reg3 = new RegExp(Evt.leanoteUrl + '/api/file/getAllAttach', 'g');
		content = content.replace(reg, Evt.localUrl + '/api/file/getAllAttach');

		return content;
	},

	// 将本地的url改下, 发送数据到服务器上
	fixNoteContentForSend: function(content) {
		if(!content) {
			return content;
		}
		console.log(Evt.localUrl + '/api/file/getImage');
		var reg = new RegExp(Evt.localUrl + '/api/file/getImage', 'g');
		content = content.replace(reg, Evt.leanoteUrl + '/api/file/getImage');

		var reg2 = new RegExp(Evt.localUrl + '/api/file/getAttach', 'g');
		content = content.replace(reg, Evt.leanoteUrl + '/api/file/getAttach');

		var reg3 = new RegExp(Evt.localUrl + '/api/file/getAllAttach', 'g');
		content = content.replace(reg, Evt.leanoteUrl + '/api/file/getAllAttach');

		return content;
	},

	// 远程修改本地内容
	updateNoteContentForce: function(noteId, content, callback) {
		var me = this;

		content = me.fixNoteContent(content);

		Notes.update({NoteId: noteId}, { $set: {Content: content, InitSync: false, IsContentDirty: false} }, {}, function (err, numReplaced) { 
			if(err) {
				log(err);
				callback && callback(false);
			} else {
				callback && callback(content);
			}
		});
	},

	/*
	// 同步内容
	updateNoteContentForce: function(noteId, content, callback) {
		// 将笔记内容中

		Notes.update({NoteId: noteId}, { $set: {Content: content, InitSync: false} }, {}, function (err, numReplaced) { 
			if(err) {
				log(err);
				callback && callback(false);
			} else {
				callback && callback(content);
			}
		});
	},
	*/

	// 得到笔记内容
	// noteId是本地Id
	inSyncContent: {}, // 正在同步中的
	getNoteContent: function(noteId, callback) {
		var me = this;
		log('getNoteContent------')
		// 如果是正在sync的话, 返回
		if(me.inSyncContent[noteId]) {
			return;
		}
		me.inSyncContent[noteId] = true;
		me.getNote(noteId, function(note) {
			if(!Common.isOk(note)) {
				log('not ok');
				log(note);
				callback && callback(false);
			} else {
				// 如果笔记是刚同步过来的, 那么内容要重新获取
				if(note.InitSync) {
					log('need load from server');

					if(!Api) {
						Api = require('api')
					}

					// 远程获取
					me.getServerNoteIdByNoteId(noteId, function(serverNoteId) {
						if(!serverNoteId) {
							me.inSyncContent[noteId] = false;
							return callback && callback(false);
						}

						Api.getNoteContent(serverNoteId, function(noteContent) {
							me.inSyncContent[noteId] = false;
							// 同步到本地
							if(Common.isOk(noteContent)) {
								me.updateNoteContentForce(noteId, noteContent.Content, function(content) {
									noteContent.Content = content;
									noteContent.NoteId = noteId;
									callback && callback(noteContent);
								});
							} else {
								callback && callback(false);
							}
						});

					});
				} else {
					me.inSyncContent[noteId] = false;
					log('not need');
					callback && callback(note);
				}
			}
		});
	},

	//----------------
	// 同步 
	//----------------

	getNoteByServerNoteId: function(noteId, callback) {
		var me = this;
		Notes.findOne({ServerNoteId: noteId}, function(err, doc) {
			if(err || !doc) {
				log('getNoteByServerNoteId 不存在' + noteId);
				callback && callback(false);
			} else {
				callback && callback(doc);
			}
		});
	},
	getNoteIdByServerNoteId: function(noteId, callback) {
		var me = this;
		Notes.findOne({ServerNoteId: noteId}, function(err, doc) {
			if(err || !doc) {
				log('getNoteIdByServerNoteId 不存在' + noteId);
				callback && callback(false);
			} else {
				callback && callback(doc.NoteId);
			}
		});
	},
	getServerNoteIdByNoteId: function(noteId, callback) {
		var me = this;
		Notes.findOne({NoteId: noteId}, function(err, doc) {
			if(err || !doc) {
				log('getServerNoteIdByNoteId 不存在');
				callback && callback(false);
			} else {
				callback && callback(doc.ServerNoteId);
			}
		});
	},

	// 强制删除
	// TODO 是否真的删除 ?
	// 有可能服务器上删除了是误删 ?
	deleteNoteForce: function(noteId, callback) {
		var me = this;
		Notes.remove({ServerNoteId: noteId}, function(err, n) {
			if(err) { 
				callback && callback(false);
			} else {
				callback && callback(true);
			}
		});
	},
	// 添加笔记本, note object
	// note是服务器传过来的, 需要处理下fix
	// NoteId, ServerNoteId, NotebookId(本地的)
	addNoteForce: function(note, callback) {
		var me = this;
		note.InitSync = true; // 刚同步完, 表示content, images, attach没有同步
		note.IsDirty = false;
		note.ServerNoteId = note.NoteId;
		note.NoteId = Common.objectId();
		note.LocalIsDelete = false;

		// 附件操作
		var files = note.Files || [];
		var attachs = [];
		for(var i in files) {
			var file = files[i];
			if(file.IsAttach) { // LocalFileId, FileId
				file.ServerFileId = file.FileId;
				file.FileId = file.ServerFileId; // 弄成一样的, 只是没有Path
				attachs.push(file);
			}
		}
		note.Attachs = attachs;
		delete note['Files'];

		Notebook.getNotebookIdByServerNotebookId(note.NotebookId, function(localNotebookId) {
			note.NotebookId = localNotebookId;
			Notes.insert(note, function (err, newDoc) {   // Callback is optional
				if(err) {
					console.log(err);
					callback && callback(false);
				} else {
					callback && callback(newDoc);

					// 下载内容, 图片, 附件
					me.syncContentAndImagesAndAttachs(newDoc);
				}
			});
		});
	},

	// sync <- 时
	// 更新笔记, 合并之, 内容要重新获取
	// note是服务器传过来的, 需要处理下fix
	// note.NoteId是服务器的
	updateNoteForce: function(note, callback) {
		var me = this;

		note.IsDirty = false;
		note.InitSync = true;
		note.LocalIsNew = false;
		note.LocalIsDelete = false;

		// 附件处理
		var files = note.Files || [];
		var attachsMap = [];
		for(var i in files) {
			var file = files[i];
			if(file.IsAttach) { // LocalFileId, FileId
				// 对于服务器上的, 只有FileId会传过来, 此时要与之前的做对比
				file.ServerFileId = file.FileId;
				delete file['FileId'];
				attachsMap[file.ServerFileId] = file;
			}
		}

		// 之前也是有attachs的, 得到之前的attachs, 进行个merge
		me.getNoteByServerNoteId(note.NoteId, function(everNote) {
			if(!everNote) {
				return;
			}
			var everAttachs = everNote.Attachs;
			var everAttachsMap = {};

			// var needAdds = [];

			// 得到要删除的
			var needDeletes = [];
			for(var i in everAttachs) {
				var everAttach = everAttachs[i];
				everAttachsMap[everAttach.ServerFileId] = everAttach;
				if(!attachsMap[everAttach.ServerFileId]) {
					needDeletes.push(everAttach);
				}
			}
			console.log('everAttachs');
			console.log(everAttachs);
			console.log('attachsMap')
			console.log(attachsMap);
			// 通过FileId删除文件
			me.deleteAttachs(needDeletes);

			// 得到要添加的,所有的
			// 新添加的没有Path
			var allAttachs = [];
			for(var serverFileId in attachsMap) {
				if(!everAttachsMap[serverFileId]) {
					// needAdds.push(attachMap[serverFileId]);
					attachsMap[serverFileId].FileId = serverFileId; // 生成一个Id(一样的), 但是没有Path
					allAttachs.push(attachsMap[serverFileId]);
				} else {
					allAttachs.push(everAttachsMap[serverFileId]);
				}
			}
			note.Attachs = allAttachs;

			note.ServerNoteId = note.NoteId;
			note.NoteId = everNote.NoteId;
			delete note['Files'];
			// console.log('evernote');
			// console.log(everNote);

			// 得到本地笔记本Id
			Notebook.getNotebookIdByServerNotebookId(note.NotebookId, function(localNotebookId) {
				note['NotebookId'] = localNotebookId;

				console.log("updateNoteForce 后的")
				console.log(note);

				Notes.update({NoteId: note.NoteId}, {$set: note}, {}, function (err, cnt) { // Callback is optional
					console.log('re:');
					console.log(err);
					console.log(cnt);
					if(err) {
						console.log(err);
						callback && callback(false);
					} else {
						log('强制更新...');
						callback && callback(note);

						// 下载内容, 图片, 附件
						me.syncContentAndImagesAndAttachs(note);
					}
				});
			});
		});
	},

	// addNote, updateNote后的操作
	// 添加修改ServerNoteId; 更新修改usn
	updateNoteForceForSendChange: function(note, isAdd, callback) {
		var me = this;
		note.IsDirty = false;
		note.InitSync = false;
		note.LocalIsNew = false;
		// note.LocalIsDelete = false;
		// note.UserId = User.getCurActiveUserId();
		// 
		console.log("updateNoteForceForSendChange");
		console.log(note);

		// 如果是添加的, 因为不会传内容
		// if(isAdd) {
		delete note['Content'];
		// }

		console.log('server data from::::');
		console.log(note.NoteId);
		console.log(note.Files);

		// 修改Imags的LocalFileId <=> FileId的映射
		File.updateImageForce(note.Files);

		// 修改attach, 建立LocalFileId <=> FileId的映射
		var files = note.Files || [];
		var filesMap = {}; // LocalFileId => ServerFileId
		for(var i in files) {
			var file = files[i];
			if(file.IsAttach) { // LocalFileId, FileId
				filesMap[file.LocalFileId] = file.FileId;
			}
		}
		// 之前也是有attachs的, 得到之前的attachs, 进行个merge
		me.getNote(note.NoteId, function(everNote) {
			if(!everNote) {
				console.log('我靠, 没有?' + note.NoteId);
				return;
			}
			var everAttachs = everNote.Attachs || [];
			for(var i in everAttachs) {
				var everAttach = everAttachs[i];
				if(filesMap[everAttach.FileId]) {
					everAttach.ServerFileId = filesMap[everAttach.FileId];
					everAttach.IsDirty = false; // 不为dirty了, 记得在sync后也改为false
				}
			}
			note.Attachs = everAttachs;
			console.log('fix after');
			console.log(everAttachs);

			delete note['Files'];

			Notes.update({NoteId: note.NoteId}, {$set: note}, function(err, n) {
				if(err || !n) {
					log('updateNoteForceForSendChange err');
					log(err);
					return callback && callback(false);
				}
				return callback && callback(true);
			});

		});
	},

	// 服务器上的数据
	// 为冲突更新, note已有有NoteId, ServerNoteId, 但NotebookId是服务器端的
	updateNoteForceForConflict: function(note, callback) {
		var me = this;
		note.NoteId = note.ServerNoteId;
		me.updateNoteForce(note, callback);
		return;

		note.IsDirty = false;
		note.InitSync = true;
		note.LocalIsNew = false;
		note.LocalIsDelete = false;
		// 文件操作

		Notebook.getNotebookIdByServerNotebookId(note.NotebookId, function(localNotebookId) {
			note['NotebookId'] = localNotebookId;
			Notes.update({NoteId: note.NoteId}, {$set: note}, {}, function (err, cnt) {   // Callback is optional
				if(err) {
					console.log(err);
					callback && callback(false);
				} else {
					log('强制更新...');
					callback && callback(note);
				}
			});
		});
	},

	// 将本地冲突的笔记复制一份
	// serverNoteId
	// 附件也要复制一份
	copyNoteForConfict: function(noteId, callback) {
		var me = this;
		me.getNote(noteId, function(note) { 
			if(!note) {
				callback(false);
				return;
			}
			// 新Id
			delete note['_id'];
			delete note['ServerNoteId'];
			note.NoteId = Common.objectId();
			note.ConflictNoteId = noteId; // 与noteId有冲突
			note.ConflictTime = new Date(); // 发生冲突时间
			note.ConflictFixed = false; // 冲突未解决
			note.IsDirty = true;
			note.LocalIsNew = true; // 新增加的
			note.InitSync = false; // 都是本地的, 相当于新建的笔记
			note.LocalIsDelete = false;

			// 只复制有path的
			var attachs = note.Attachs || [];
			var newAttachs = [];
			console.log('不会吧.............')
			console.log(attachs);
			async.eachSeries(attachs, function(attach, cb) {
				if(!attach.Path) {
					return cb();
				}
				// 新路径
				var filePathAttr = Common.splitFile(attach.Path);
				filePathAttr.nameNotExt += '_cp_' + attach.FileId; // 另一个
				var newPath = filePathAttr.getFullPath();
				console.log('复制文件');
				console.log(attach);
				// 复制之
				// try {
					Common.copyFile(attach.Path, newPath, function(ret) {
						if(ret) {
							attach.FileId = Common.objectId();
							attach.IsDirty = true;
							attach.Path = newPath;
							delete attach['ServerFileId'];
							newAttachs.push(attach);
						}
						cb();
					});
					/*
				} catch(e) {
					cb();
				}
				*/
			}, function() {
				note.Attachs = newAttachs;
				console.log('conflict 复制后的');
				console.log(note.Attachs);
				Notes.insert(note, function(err, newNote) {
					if(err) {
						callback(false);

					} else {
						callback(newNote);
						// 重新统计笔记本的笔记数量
						Notebook.reCountNotebookNumberNotes(newNote.NotebookId);
					}
				});
			});
		});
	},

	// 复制笔记到某笔记本下, 本地使用
	copyNote: function(noteId, notebookId, callback) {
		var me = this;
		me.getNote(noteId, function(note) { 
			if(!note) {
				callback(false);
				return;
			}
			// 新Id
			delete note['_id'];
			delete note['ServerNoteId'];
			note.NoteId = Common.objectId();
			note.IsDirty = true;
			note.LocalIsNew = true; // 新增加的
			note.InitSync = false; // 都是本地的, 相当于新建的笔记
			note.LocalIsDelete = false;
			note.IsTrash = false;
			note.NotebookId = notebookId;

			// 只复制有path的
			var attachs = note.Attachs || [];
			var newAttachs = [];
			async.eachSeries(attachs, function(attach, cb) {
				if(!attach.Path) {
					return cb();
				}
				// 新路径
				var filePathAttr = Common.splitFile(attach.Path);
				filePathAttr.nameNotExt += '_cp_' + attach.FileId; // 另一个
				var newPath = filePathAttr.getFullPath();
				// 复制之
				// try {
					Common.copyFile(attach.Path, newPath, function(ret) {
						if(ret) {
							attach.FileId = Common.objectId();
							attach.IsDirty = true;
							attach.Path = newPath;
							delete attach['ServerFileId'];
							newAttachs.push(attach);
						}
						cb();
					});
					/*
				} catch(e) {
					cb();
				}
				*/
			}, function() {
				note.Attachs = newAttachs;
				console.log('conflict 复制后的');
				console.log(note.Attachs);
				Notes.insert(note, function(err, newNote) {
					if(err) {
						callback(false);
					} else {
						callback(newNote);
						// 重新统计下
						Notebook.reCountNotebookNumberNotes(newNote.NotebookId);
					}
				});
			});
		});
	},

	// 处理冲突
	// notes是服务器的数据, 与本地的有冲突
	// 1) 将本地的note复制一份
	// 2) 服务器替换之前
	fixConflicts: function(noteSyncInfo, callback) {
		var me = this;

		var conflictNotes = noteSyncInfo.conflicts;
		log('fix note conflicts');
		log(conflictNotes);
		// 这里为什么要同步? 因为fixConflicts后要进行send changes, 这些有冲突的不能发送changes
		if(conflictNotes) {
			async.eachSeries(conflictNotes, function(note, cb) { // note是服务器上最新的, note.NoteId, ServerNoteId已转换
				var noteId = note.NoteId; // 本地noteId
				// 复制一份, 本地的复制一份, 然后服务器上的替换本地的
				me.copyNoteForConfict(noteId, function(newNote) {
					if(newNote) {
						// 更新之前的
						me.updateNoteForceForConflict(note, function(note2) { 
							if(note2) {
								// 前端来处理, 全量sync时不用前端一个个处理
								Web.fixSyncConflictNote(note2, newNote);
							}
							cb();
						});
					} else {
						cb();
					}
				});
			}, function() {
				// 最后调用
				callback && callback();
			});
		} else {
			callback && callback();
		}

		// 发送改变的冲突
		// 复制一份
		// [待测]
		var changeConflicts = noteSyncInfo.changeConflicts;
		console.log('changeConflicts');
		console.log(changeConflicts);
		for(var i in changeConflicts) {
			var note = changeConflicts[i]; // note是本地的note
			// 复制一份
			me.copyNoteForConfict(note.NoteId, function(newNote) {
				if(newNote) {
					// 更新之前的, 要先从服务器上得到服务版的
					// 这里的note是本地的, 所以将服务器上的覆盖它
					if(!Api) {
						Api = require('api');
					}
					Api.getNote(note.ServerNoteId, function(serverNote) {
						serverNote.ServerNoteId = serverNote.NoteId;
						serverNote.NoteId = note.NoteId;
						me.updateNoteForceForConflict(serverNote, function(note2) { 
							if(!note2) {
								// 前端来处理, 全量sync时不用前端一个个处理
								Web.fixSyncConflict(note2, newNote);
							}
						});
					});
				} else {
				}
			});
		}

		// 服务器没有, 但是是发送更新的, 所以需要作为添加以后再send changes
		if(noteSyncInfo.changeNeedAdds) { 
			var needAddNotes = noteSyncInfo.changeNeedAdds;
			for(var i in needAddNotes) {
				log('need add ');
				var note = needAddNotes[i];
				me.setIsNew(note.NoteId);
			}
		}

		// 处理添加的
		var addNotes = noteSyncInfo.adds;
		log('has add...');
		log(addNotes);
		Web.addSyncNote(addNotes);

		log('has updates...');
		log(noteSyncInfo);
		log(noteSyncInfo.updates);
		// 处理更新的
		Web.updateSyncNote(noteSyncInfo.updates);

		// 处理删除的
		Web.deleteSyncNote(noteSyncInfo.deletes);
	},

	// 得到所有文件要传的基本信息和传送的数据
	getFilesPostInfo: function(files, callback) {
		var needPostFilesAttr = [];
		var needTransferFiles = {};
		if(!files || files.length == 0) {
			return callback(needPostFilesAttr, needTransferFiles);
		}

		async.eachSeries(files, function(file, cb) {
			// var file = files[i];
			var needFile = {
				FileId: file.ServerFileId,
				LocalFileId: file.FileId,
				Type: file.Type,
				HasBody: false,
				IsAttach: file.IsAttach,
			};

			// console.log(file);
			// 要传数据的
			if(file.IsDirty) {
				// TODO
				if(file.Path.indexOf('data/') == 0) {
					file.Path = Evt.getAbsolutePath(file.Path);
				}
				fs.exists(file.Path, function(isExists) {
					if(isExists) {
						needTransferFiles[file.FileId] = {
							file: file.Path,
							content_type: 'application/' + file.Type // TODO
						}
						if(file.Title) {
							needTransferFiles[file.FileId].filename = file.Title;
						}
						needFile.HasBody = true;
						needPostFilesAttr.push(needFile);
					}
					return cb();
				});
			} else {
				needPostFilesAttr.push(needFile);
				return cb();
			}
		}, function() {
			callback(needPostFilesAttr, needTransferFiles);
		});
	},

	// 获得用户修改的笔记
	getDirtyNotes: function(callback) {
		var me = this;
		Notes.find({UserId: User.getCurActiveUserId(), IsDirty: true}, function(err, notes) {
			if(err) {
				log(err);
				return callback && callback(false);
			} else {
				// 每一个笔记得到图片, 附件信息和数据
				async.eachSeries(notes, function(note, cb) {
					me.getNoteFiles(note, function(files) {
						note.Content = me.fixNoteContentForSend(note.Content);
						// note.Files = files || [];
						me.getFilesPostInfo(files, function(attrs, fileDatas) { 
							note.Files = attrs;
							note.FileDatas = fileDatas;
							cb();
						});
					});
				}, function() {
					callback(notes);
				});
			}
		});
	},

	// 得到笔记的文件
	getNoteFiles: function(note, callback) {
		var noteId = note.NoteId;
		var content = note.Content;

		// 1. 先得到附件
		var attachs = note.Attachs || [];
		for(var i in attachs) {
			var attach = attachs[i];
			attach.IsAttach = true;
		}

		// 1. 先得到图片

		// 得到图片信息, 通过内容
		// http://localhost:8002/api/file/getImage?fileId=xxxxxx, 得到fileId, 查询数据库, 得到图片
		// console.log(content);
		// console.log(Evt.localUrl + '/api/file/getImage?fileId=([0-9a-zA-Z]{24})');
		var reg = new RegExp(Evt.localUrl + "/api/file/getImage\\?fileId=([0-9a-zA-Z]{24})", 'g');
		var fileIds = [];
		// var fileIdsMap = {}; // 防止多个
		while((result = reg.exec(content)) != null) {
			// result = [所有, 子表达式1, 子表达式2]
			if(result && result.length > 1) {
	            // console.log(result);
				var fileId = result[1];
				fileIds.push(fileId);
			}
        }
        var files = []; // {localFileId: "must", fileId: "", hasBody: true, filename: "xx.png"}
        if(fileIds.length > 0) {
        	// 得到所有的图片
        	File.getAllImages(fileIds, function(images) {
        		// attach与图片结合
        		if(images) {
        			attachs = attachs.concat(images);
        		}
        		callback(attachs);
        	});
        } else {
        	callback(attachs);
        }
	},

	// 在send delete笔记时成功
	setNotDirty: function(noteId) {
		Notes.update({NoteId: noteId}, {$set:{IsDirty: false}})
	},
	// 在send delete笔记时有冲突, 设为不删除
	setNotDirtyNotDelete: function(noteId) {
		Notes.update({NoteId: noteId}, {$set:{IsDirty: false, LocalIsDelete: false}})
	},
	setIsNew: function(noteId) {
		Notes.update({NoteId: noteId}, {$set:{LocalIsNew: true, IsDirty: true}})
	},

	//----------------------------------
	// Attach
	// 有部分操作放在File中了, 
	// 也有attach表, 但只作添加/删除附件用
	// 

	// 更新笔记的附件
	// web只要一个添加了, 删除的, 全部更新
	updateAttach: function(noteId, attachs) {
		var me = this;
		console.log('updateAttach');
		console.log(attachs);

		// 删除修改了的
		me.deleteNotExistsAttach(noteId, attachs, function() {
			// 一个坑!!!!!!!!!!!, js是引用的, needb并不会立即写到硬盘上, 在内存中是一个引用
			var t = [];
			for(var i in attachs) {
				t.push(attachs[i]);
			}
			Notes.update({NoteId: noteId}, {$set: {Attachs: t, IsDirty: true, UpdatedTime: new Date()}} );
		});
	},

	// web端操作, 删除attach时, 删除不要的attach
	deleteNotExistsAttach: function(noteId, attachs, callback) {
		var me = this;
		// console.log('--');
		me.getNote(noteId, function(note) {
			if(!note) {
				callback();
				return;
			}
			var everAttachs = note.Attachs || [];
			var nowMap = {};
			for(var i in attachs) {
				nowMap[attachs[i].FileId] = attachs[i];
			}
			// console.log(note);
			// console.log('end');
			// console.log(everAttachs.length);
			// console.log(attachs.length);
			// console.log(attachs == everAttachs);
			var fileBasePath = User.getCurUserAttachsPath();
			for(var i in everAttachs) {
				var attach = everAttachs[i];
				var path = attach.Path;
				if(!nowMap[attach.FileId]) { // 如果不在, 则删除之
					// console.log(">>>>>>>>>");
					try {
						// 删除源文件, 别删错了啊
						if(path.indexOf(fileBasePath) >= 0) {
							fs.unlink(path);
						}
					} catch(e) {
						console.log(e);
					}
				}
			}

			// 一个坑!!!!!!!!!!!
			callback();
		});
	},

	// 删除附件, 在sync时
	deleteAttachs: function(attachs) {
		var me = this;
		var fileBasePath = User.getCurUserAttachsPath();
		if(!attachs) {
			return;
		}
		for(var i in attachs) {
			var path = attachs[i].Path;
			if(path && path.indexOf(fileBasePath) > 0) {
				try {
					fs.unlink(path);
				} catch(e) {
					console.log(e);
				}
			}
		}
	},

	// 同步内容, 图片, 附件
	// 异步操作
	// 延迟1s
	syncContentAndImagesAndAttachs: function(note) {
		var me = this;
		setTimeout(function() {
			// 内容
			console.log("syncContentAndImagesAndAttachs..................." + note.NoteId);
			me.getNoteContent(note.NoteId, function(noteAndContent) { 
				if(noteAndContent) {
					console.log('sync content ' + note.NoteId + ' ok');
					var content = noteAndContent.Content;
					Web.contentSynced(note.NoteId, note.Content);
					// 图片
					if(content) {
						me.syncImages(content);
					}
				}
			});

			// 附件
			var attachs = note.Attachs || [];
			for(var i in attachs) {
				var attach = attachs[i];
				me.downloadAttachFromServer(note.NoteId, attach.ServerFileId, attach.FileId);
			}
		}, 1000);
	},

	// 同步图片
	inSyncImage: {}, // 
	syncImages: function(content) {
		var me = this;
		if(!content) {
			return;
		}
		console.log('syncImages..................');
		// console.log(content);
		// 得到图片id
		var reg = new RegExp(Evt.localUrl + "/api/file/getImage\\?fileId=(.{24})\"", 'g');
		// var a = 'abdfileId="xxx" alksdjfasdffileId="life"';
		// var reg = /fileId="(.+?)"/g;
		var s;
		// console.log(reg);
		while(s = reg.exec(content)) {
			// console.log(s);
			if(s && s.length >= 2) {
				var fileId = s[1];
				console.log('sync image: ' + fileId);
				if(!me.inSyncImage[fileId]) {
					me.inSyncImage[fileId] = true;
					File.getImage(fileId, function() {
						me.inSyncImage[fileId] = false;
					});
				}
			}
		}
	},

	/*
	1) sync时判断是否有attach, 如果有, 则异步下载之
	2) 前端render note时, 判断是否有未Path的attach, 调用该服务
	从服务器端下载文件, 并通过到前端已下载完成
	*/
	inDownload: {}, // 正在下载的文件 fileId => true
	downloaded: {}, // 下载完成的
	downloadAttachFromServer: function(noteId, serverFileId, fileId) {
		var me = this;
		if(me.inDownload[serverFileId] || me.downloaded[serverFileId]) {
			return;
		}
		if(!Api) {
			Api = require('api');
		}

		me.inDownload[serverFileId] = true;
		Api.getAttach(serverFileId, function(ok, toPath, filename) { 
			me.inDownload[serverFileId] = false;
			if(ok) {
				me.downloaded[serverFileId] = fileId;
				// 更新serverFileId与fileId的映射, 修改的是note
				me.syncAttach(noteId, serverFileId, fileId, toPath, filename, function(ok, attachs, attach) {
					if(ok) {
						// 通知web
						Web.attachSynced(attachs, attach, noteId);
					}
				});
			} else {
				// 下次再下载 ?
				// 或者放到一个队列中 ?
				// TODO
			}
		});
	},

	// 同步附件, 更新serverFileId
	syncAttach: function(noteId, serverFileId, fileId, path, filename, callback) {
		var me = this;
		me.getNote(noteId, function(note) {
			if(!note) {
				callback(false);
			}
			var attachs = note.Attachs;
			for(var i in attachs) {
				var attach = attachs[i];
				if(attach.FileId == fileId) {
					attach.ServerFileId = serverFileId;
					attach.Path = path;
					// attach.Title = filename;
					// attach.Filename = filename;

					Notes.update({_id: note._id}, {$set: {Attachs: attachs}}, function() {
						callback(true, attachs, attach);
					});
					break;
				}
			}
			callback(false);
		});
	},

	// 根据标签得到笔记数量
	countNoteByTag: function(title, callback) {
		var userId = User.getCurActiveUserId();
		Notes.count({UserId: userId, LocalIsDelete: false , Tags: {$in: [title]}}, function(err, cnt) {
			callback && callback(cnt);
		});
	},
	// 彻底删除笔记时调用
	updateTagCount: function(tags) {
		if(!tags) {
			return;
		}
		var tagUpdate = {}; // 
		if(!Tag) {
			Tag = require('tag');
		}

		var userId = User.getCurActiveUserId();
		for(var i in tags) {
			var title = tags[i];
			(function(t) {
				me.countNoteByTag(t, function(cnt) {
					Tag.updateTagCount(t, cnt);
				});
			})(title);
		}
	},
	// 删除包含title的笔记
	updateNoteToDeleteTag: function(title, callback) {
		var updates = {}; // noteId => 
		var userId = User.getCurActiveUserId();
		console.log('updateNoteToDeleteTag--');
		Notes.find({UserId: userId, LocalIsDelete: false , Tags: {$in: [title]}}, function(err, notes) {
			console.log(notes);
			if(!err && notes && notes.length > 0) {
				for(var i in notes) {
					var note = notes[i];
					var tags = note.Tags;
					// 删除之
					for(var j in tags) {
						if(tags[j] == title) {
							tags = tags.splice(j, 1);
							break;
						}
					}
					note.Tags = tags;
					note.IsDirty = true;
					updates[note.NoteId] = note;
					Notes.update({_id: note._id}, {$set: {Tags: tags, IsDirty: true}}, function(err) {
						console.log("??");
						console.log(err);
						callback(updates);
					});
				}
			} else {
				console.log('updateNoteToDeleteTag');
				console.log(err);
				callback({});
			}
		});

	}
};

module.exports = Note;